<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Three.js FPS — PointerLock 안전 처리 포함</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#111;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',Arial}
    #overlay{position:absolute;top:8px;left:8px;z-index:20;background:rgba(0,0,0,0.45);padding:10px 12px;border-radius:8px;backdrop-filter:blur(4px)}
    #info{font-size:14px;line-height:1.4}
    #startBtn{display:block;margin-top:8px;padding:8px 12px;border-radius:6px;background:#2b6df6;color:#fff;border:none;cursor:pointer}
    #fallbackControls{margin-top:8px;display:none}
    .btn{display:inline-block;padding:6px 10px;border-radius:6px;background:#444;color:#fff;border:none;cursor:pointer;margin-right:6px}
    #centerDot{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:6px;height:6px;border-radius:50%;background:rgba(255,255,255,0.9);z-index:2;pointer-events:none}
    canvas{display:block}
    #note{font-size:12px;color:#cfcfcf;margin-top:6px}
  </style>

  <!-- importmap: bare specifier 'three' 매핑 -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="overlay">
    <div id="info">
      <div>체력: <span id="hp">100</span></div>
      <div>탄약: <span id="ammo">60</span> / <span id="mag">30</span></div>
      <div>킬: <span id="kills">0</span></div>
      <div id="note">WASD 이동 · 마우스 시선(포인터락 선호) · 좌클릭 사격 · R 재장전</div>
    </div>
    <button id="startBtn">게임 시작 (클릭 → 포인터락 시도)</button>

    <div id="fallbackControls">
      <div style="margin-top:8px">포인터락이 차단되었습니다. 아래 옵션 중 하나를 선택하세요.</div>
      <div style="margin-top:6px">
        <button id="enableMouseLook" class="btn">마우스 드래그로 시선 제어 (대체 모드)</button>
        <button id="openNewTab" class="btn">새 탭에서 열기</button>
      </div>
      <div style="margin-top:8px;font-size:12px;color:#ddd">참고: 만약 이 페이지가 iframe으로 열려 있고 포인터락이 필요하다면 iframe에 <code>allow="fullscreen;autoplay;accelerometer;camera;microphone;geolocation;picture-in-picture;clipboard-write;allow-pointer-lock"</code> 혹은 <code>allow-pointer-lock</code> 권한을 추가해야 합니다.</div>
    </div>
  </div>
  <div id="centerDot"></div>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js';

    // --- 기본 씬 구성 ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x9fc6ff);
    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 400);
    camera.position.set(0,1.6,0);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // --- 라이트 ---
    const hemi = new THREE.HemisphereLight(0xffffff, 0x777788, 0.8); hemi.position.set(0,50,0); scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 0.9); sun.position.set(30,60,10); sun.castShadow = true; scene.add(sun);

    // --- 지형 (얕은 언덕) ---
    const SIZE = 140, SEG = 140;
    const groundGeo = new THREE.PlaneGeometry(SIZE, SIZE, SEG, SEG); groundGeo.rotateX(-Math.PI/2);
    const posAttr = groundGeo.attributes.position;
    for (let i=0;i<posAttr.count;i++){
      const x = posAttr.getX(i), z = posAttr.getZ(i);
      const h = Math.sin(x*0.04)*1.6 + Math.cos(z*0.03)*1.2 + Math.sin((x+z)*0.02)*0.8;
      const r = (Math.sin(x*0.11+z*0.07)+Math.cos(z*0.13-x*0.09))*0.3;
      posAttr.setY(i, h + r);
    }
    groundGeo.computeVertexNormals();
    const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color:0x7fb36b, roughness:1 }));
    ground.receiveShadow = true; scene.add(ground);

    // --- 장애물 ---
    const obstacles = [];
    const rockGeom = new THREE.DodecahedronGeometry(1.3, 0);
    const rockMat = new THREE.MeshStandardMaterial({ color:0x59544d });
    for (let i=0;i<24;i++){
      const mesh = new THREE.Mesh(rockGeom.clone(), rockMat.clone());
      mesh.castShadow = true; mesh.receiveShadow = true;
      mesh.position.x = (Math.random()-0.5)*(SIZE-20);
      mesh.position.z = (Math.random()-0.5)*(SIZE-20);
      mesh.position.y = getHeightAt(mesh.position.x, mesh.position.z) + 0.7 + Math.random()*0.8;
      mesh.scale.setScalar(0.8 + Math.random()*1.8);
      if (!mesh.geometry.boundingSphere) mesh.geometry.computeBoundingSphere();
      scene.add(mesh); obstacles.push(mesh);
    }

    function getHeightAt(x,z){
      const hx = Math.round(((x + SIZE/2)/SIZE)*SEG);
      const hz = Math.round(((z + SIZE/2)/SIZE)*SEG);
      const xi = Math.max(0, Math.min(SEG, hx));
      const zi = Math.max(0, Math.min(SEG, hz));
      const idx = zi*(SEG+1) + xi;
      return groundGeo.attributes.position.getY(idx);
    }

    // --- HUD / UI ---
    const hpEl = document.getElementById('hp');
    const ammoEl = document.getElementById('ammo');
    const magEl = document.getElementById('mag');
    const killsEl = document.getElementById('kills');
    const startBtn = document.getElementById('startBtn');
    const fallbackControls = document.getElementById('fallbackControls');
    const enableMouseLookBtn = document.getElementById('enableMouseLook');
    const openNewTabBtn = document.getElementById('openNewTab');

    // --- 컨트롤(포인터락) ---
    const controls = new PointerLockControls(camera, document.body);
    const playerHolder = new THREE.Object3D();
    playerHolder.position.set(0,1.6,0);
    playerHolder.add(camera);
    scene.add(playerHolder);
    controls.getObject = () => playerHolder;

    // 포인터락 차단 여부 추적
    let pointerLockBlocked = false;
    let fallbackMouseLook = false;

    // --- 플레이어 상태 ---
    const player = { velocity: new THREE.Vector3(), direction: new THREE.Vector3(), speed:6, height:1.6, canJump:true, hp:100, ammo:60, mag:30, kills:0 };
    hpEl.textContent = player.hp; ammoEl.textContent = player.ammo; magEl.textContent = player.mag;

    // --- 오디오 ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playGunshot(){
      const bufferSize = Math.floor(audioCtx.sampleRate * 0.18);
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1) * Math.exp(-i/(bufferSize*0.08)); }
      const src = audioCtx.createBufferSource(); src.buffer = buffer;
      const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 4000;
      const g = audioCtx.createGain(); g.gain.value = 0.9;
      src.connect(lp); lp.connect(g); g.connect(audioCtx.destination); src.start();
      const osc = audioCtx.createOscillator(); osc.type='sawtooth'; osc.frequency.value = 120;
      const g2 = audioCtx.createGain(); g2.gain.value = 0.2; osc.connect(g2); g2.connect(audioCtx.destination); osc.start(); osc.stop(audioCtx.currentTime + 0.06);
    }
    function playReload(){ const now = audioCtx.currentTime; for (let i=0;i<6;i++){ const o = audioCtx.createOscillator(); o.type='square'; o.frequency.value = 800 - i*40; const gg = audioCtx.createGain(); gg.gain.value = 0.15 * Math.exp(-i*0.2); o.connect(gg); gg.connect(audioCtx.destination); o.start(now + i*0.03); o.stop(now + i*0.03 + 0.06); } }

    // --- 사격 ---
    const raycaster = new THREE.Raycaster();
    let lastShot = 0; const shotCooldown = 0.12; let lastNoisePos = null;
    function shoot(){
      const now = performance.now()/1000;
      if (now - lastShot < shotCooldown) return; if (player.mag <= 0) return;
      if (audioCtx.state === 'suspended') audioCtx.resume();
      lastShot = now; player.mag -= 1; if (player.ammo > 0) player.ammo -= 1;
      ammoEl.textContent = player.ammo; magEl.textContent = player.mag; playGunshot();
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const hits = raycaster.intersectObjects(enemies.map(e=>e.mesh));
      if (hits.length>0){ const h = hits[0].object.userData.owner; h.hp -= 35; h.mesh.material.emissive = new THREE.Color(0x440000); setTimeout(()=>h.mesh.material.emissive.setHex(0x000000),80); if (h.hp <= 0) killEnemy(h); }
      lastNoisePos = controls.getObject().position.clone(); lastNoisePos.time = now;
    }

    document.addEventListener('mousedown', (e)=>{ if (e.button===0 && controls.isLocked) shoot(); });
    document.addEventListener('keydown', (e)=>{ if (e.key.toLowerCase()==='r') reload(); });
    function reload(){ if (player.ammo <= 0 || player.mag >= 30) return; playReload(); const toLoad = Math.min(30 - player.mag, player.ammo); player.mag += toLoad; player.ammo -= toLoad; ammoEl.textContent = player.ammo; magEl.textContent = player.mag; }

    // --- 적 AI ---
    const enemies = [];
    const enemyGeom = THREE.CapsuleGeometry ? new THREE.CapsuleGeometry(0.45,0.6,4,8) : new THREE.CylinderGeometry(0.45,0.45,1.8,8);
    const enemyMatBase = new THREE.MeshStandardMaterial({ color:0xff6666 });
    function spawnEnemy(){ const mesh = new THREE.Mesh(enemyGeom, enemyMatBase.clone()); mesh.castShadow = true; mesh.receiveShadow = true; const angle = Math.random()*Math.PI*2; const r = 28 + Math.random()*24; mesh.position.set(Math.cos(angle)*r, 0, Math.sin(angle)*r); mesh.position.y = getHeightAt(mesh.position.x, mesh.position.z) + 0.9; const obj = { mesh, state:'patrol', hp:60 + Math.floor(Math.random()*20), speed:1 + Math.random()*0.8, targetPos: randomPatrolPoint(), lastSeen:0, hearTime:0 }; mesh.userData.owner = obj; if (!mesh.geometry.boundingSphere) mesh.geometry.computeBoundingSphere(); enemies.push(obj); scene.add(mesh); }
    function randomPatrolPoint(){ return new THREE.Vector3((Math.random()-0.5)*(SIZE-20),0,(Math.random()-0.5)*(SIZE-20)); }
    function killEnemy(e){ scene.remove(e.mesh); const idx = enemies.indexOf(e); if (idx!==-1) enemies.splice(idx,1); player.kills += 1; killsEl.textContent = player.kills; }
    for (let i=0;i<6;i++) spawnEnemy();
    const sightRay = new THREE.Raycaster();
    function updateEnemies(delta){ const ppos = controls.getObject().position.clone(); for (const e of enemies){ const toPlayer = ppos.clone().sub(e.mesh.position); const dist = toPlayer.length(); let canSee = false; if (dist < 40){ sightRay.set(e.mesh.position.clone().add(new THREE.Vector3(0,0.6,0)), toPlayer.normalize()); const hits = sightRay.intersectObjects([ground, ...obstacles, ...enemies.map(x=>x.mesh)], true); if (hits.length===0) canSee = true; else { if (hits[0].distance >= dist - 0.6) canSee = true; } } if (lastNoisePos && (performance.now()/1000 - lastNoisePos.time) < 1.0){ const hearDist = e.mesh.position.distanceTo(lastNoisePos); if (hearDist < 30){ e.state = 'investigate'; e.targetPos = lastNoisePos.clone(); e.hearTime = performance.now()/1000; } } if (canSee){ e.state = 'chase'; e.lastSeen = performance.now()/1000; } if (e.state==='chase' && (performance.now()/1000 - e.lastSeen) > 6){ e.state='search'; e.targetPos = ppos.clone(); } if (e.state==='patrol'){ const dir = e.targetPos.clone(); dir.y = getHeightAt(dir.x, dir.z); dir.sub(e.mesh.position); const d = dir.length(); if (d < 1.2) e.targetPos = randomPatrolPoint(); else { dir.normalize(); e.mesh.position.addScaledVector(dir, e.speed * delta); } } else if (e.state==='investigate'){ const dir = e.targetPos.clone(); dir.y = getHeightAt(dir.x,dir.z); dir.sub(e.mesh.position); if (dir.length() < 1.2 || (performance.now()/1000 - e.hearTime) > 4) { e.state='patrol'; e.targetPos = randomPatrolPoint(); } else { dir.normalize(); e.mesh.position.addScaledVector(dir, e.speed * 1.1 * delta); } } else if (e.state==='search'){ const dir = e.targetPos.clone(); dir.y = getHeightAt(dir.x,dir.z); dir.sub(e.mesh.position); if (dir.length() < 1.5) { e.state='patrol'; e.targetPos=randomPatrolPoint(); } else { dir.normalize(); e.mesh.position.addScaledVector(dir, e.speed * delta); } } else if (e.state==='chase'){ const dir = ppos.clone(); dir.y = getHeightAt(ppos.x,ppos.z); dir.sub(e.mesh.position); if (dir.length() > 0.1){ dir.normalize(); const ahead = e.mesh.position.clone().addScaledVector(dir, 1.0); let blocked = false; for (const ob of obstacles){ const br = ob.geometry.boundingSphere ? ob.geometry.boundingSphere.radius * ob.scale.x : 1.5; if (ahead.distanceTo(ob.position) < 1.6 + br){ blocked = true; break; } } if (blocked){ const side = new THREE.Vector3(dir.z,0,-dir.x); e.mesh.position.addScaledVector(side.normalize(), e.speed * delta * 0.8); } e.mesh.position.addScaledVector(dir, e.speed * 1.3 * delta); } if (e.mesh.position.distanceTo(ppos) < 1.6){ player.hp -= 12 * delta; hpEl.textContent = Math.max(0, Math.floor(player.hp)); if (player.hp <= 0){ alert('사망했습니다. 새로고침하여 재시작하세요.'); location.reload(); return; } } } const targetY = getHeightAt(e.mesh.position.x, e.mesh.position.z) + 0.9; e.mesh.position.y += (targetY - e.mesh.position.y) * 10 * delta; } }

    // --- 장애물 회피 ---
    function avoidObstacles(pos){ const corrected = pos.clone(); for (const ob of obstacles){ const dx = corrected.x - ob.position.x; const dz = corrected.z - ob.position.z; const dist = Math.hypot(dx,dz); const minDist = (ob.geometry.boundingSphere?ob.geometry.boundingSphere.radius*ob.scale.x:1.5) + 0.8; if (dist < minDist && dist>0.001){ const push = (minDist - dist) + 0.01; corrected.x += (dx/dist) * push; corrected.z += (dz/dist)*push; } } return corrected; }

    function maybeSpawn(){ if (enemies.length < 8 && Math.random() < 0.01) spawnEnemy(); }

    // --- 애니메이션 루프 ---
    const clock = new THREE.Clock();
    function animate(){ 
        const delta = Math.min(0.1, clock.getDelta()); 
        if (controls.isLocked){ 
            player.direction.set(0,0,0); 
            if (keys.forward) player.direction.z -= 1; 
            if (keys.back) player.direction.z += 1; 
            if (keys.left) player.direction.x -= 1; if (keys.right) player.direction.x += 1; player.direction.normalize(); const camQ = camera.quaternion.clone(); const move = new THREE.Vector3(player.direction.x,0,player.direction.z).applyQuaternion(camQ); move.y = 0; if (move.length()>0) move.normalize(); const targetVel = move.multiplyScalar(player.speed); player.velocity.x += (targetVel.x - player.velocity.x) * 10 * delta; player.velocity.z += (targetVel.z - player.velocity.z) * 10 * delta; player.velocity.y -= 9.8 * delta; const pos = controls.getObject().position; const nextPos = pos.clone().addScaledVector(player.velocity, delta); if (nextPos.y < player.height) { player.velocity.y = 0; nextPos.y = player.height; player.canJump = true; } const corrected = avoidObstacles(new THREE.Vector3(nextPos.x, nextPos.y, nextPos.z)); corrected.y = getHeightAt(corrected.x, corrected.z) + player.height - 0.0; controls.getObject().position.copy(corrected); } else if (fallbackMouseLook){ // 마우스 드래그 대체 모드에서도 이동은 가능
        player.direction.set(0,0,0);
        if (keys.forward) player.direction.z -= 1;
        if (keys.back) player.direction.z += 1;
        if (keys.left) player.direction.x -= 1;
        if (keys.right) player.direction.x += 1;
        player.direction.normalize();
        // yaw는 playerHolder.rotation.y, pitch는 camera.rotation.x (clamped)
        const yaw = playerHolder.rotation.y;
        const moveVec = new THREE.Vector3(player.direction.x,0,player.direction.z).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        if (moveVec.length()>0) moveVec.normalize();
        const targetVel = moveVec.multiplyScalar(player.speed);
        player.velocity.x += (targetVel.x - player.velocity.x) * 10 * delta;
        player.velocity.z += (targetVel.z - player.velocity.z) * 10 * delta;
        player.velocity.y -= 9.8 * delta;
        const pos = controls.getObject().position;
        const nextPos = pos.clone().addScaledVector(player.velocity, delta);
        if (nextPos.y < player.height) { player.velocity.y = 0; nextPos.y = player.height; player.canJump = true; }
        const corrected = avoidObstacles(new THREE.Vector3(nextPos.x, nextPos.y, nextPos.z));
        corrected.y = getHeightAt(corrected.x, corrected.z) + player.height - 0.0;
        controls.getObject().position.copy(corrected);
      }
      updateEnemies(delta);
      maybeSpawn();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // --- 입력: 키 ---
    const keys = { forward:false, back:false, left:false, right:false };
    document.addEventListener('keydown',(e)=>{ if (e.code==='KeyW') keys.forward=true; if (e.code==='KeyS') keys.back=true; if (e.code==='KeyA') keys.left=true; if (e.code==='KeyD') keys.right=true; if (e.code==='Space' && player.canJump){ player.velocity.y = 8; player.canJump=false; } });
    document.addEventListener('keyup',(e)=>{ if (e.code==='KeyW') keys.forward=false; if (e.code==='KeyS') keys.back=false; if (e.code==='KeyA') keys.left=false; if (e.code==='KeyD') keys.right=false; });

    // --- 포인터락 에러/차단 처리 ---
    function onPointerLockBlocked(err){
      console.warn('Pointer lock blocked or failed', err);
      pointerLockBlocked = true;
      fallbackControls.style.display = 'block';
      // startBtn는 계속 보이도록 두면 사용자 혼란. 숨기지 말고 대체 모드 버튼을 노출
    }

    // pointerlockerror(비동기) 처리
    document.addEventListener('pointerlockerror', ()=> onPointerLockBlocked());

    // 시도(사용자 클릭) — try/catch로 동기적 예외 처리
    startBtn.addEventListener('click', async ()=>{
      try{
        // audio resume은 사용자 제스처에서 처리
        if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
      }catch(e){console.warn('audio resume failed', e);} 

      try{
        controls.lock();
      }catch(err){
        // requestPointerLock이 throw 하면 여기로 옴
        onPointerLockBlocked(err);
      }
    });

    // 포인터락 성공/해제 이벤트
    controls.addEventListener('lock', ()=>{ startBtn.style.display = 'none'; fallbackControls.style.display = 'none'; pointerLockBlocked = false; console.log('pointer locked'); });
    controls.addEventListener('unlock', ()=>{ startBtn.style.display = 'block'; console.log('pointer unlocked'); });

    // --- 대체: 마우스 드래그로 시선 제어 ---
    let mouseDown = false; let lastMouse = {x:0,y:0};
    const sensitivity = 0.0026;
    function enableMouseLook(){
      fallbackMouseLook = true; fallbackControls.style.display = 'none'; startBtn.style.display = 'none';
      // resume audio if needed
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
      renderer.domElement.style.cursor = 'grab';
      document.addEventListener('mousedown', onDocMouseDown);
      document.addEventListener('mouseup', onDocMouseUp);
      document.addEventListener('mousemove', onDocMouseMove);
      // touch support
      document.addEventListener('touchstart', onTouchStart, {passive:false});
      document.addEventListener('touchmove', onTouchMove, {passive:false});
    }
    function onDocMouseDown(e){ if (e.button !== 0) return; mouseDown = true; lastMouse.x = e.clientX; lastMouse.y = e.clientY; renderer.domElement.style.cursor = 'grabbing'; }
    function onDocMouseUp(e){ mouseDown = false; renderer.domElement.style.cursor = 'grab'; }
    function onDocMouseMove(e){ if (!fallbackMouseLook || !mouseDown) return; const movementX = (e.movementX !== undefined) ? e.movementX : e.clientX - lastMouse.x; const movementY = (e.movementY !== undefined) ? e.movementY : e.clientY - lastMouse.y; lastMouse.x = e.clientX; lastMouse.y = e.clientY; playerHolder.rotation.y -= movementX * sensitivity; camera.rotation.x -= movementY * sensitivity; camera.rotation.x = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, camera.rotation.x)); }
    function onTouchStart(e){ if (e.touches && e.touches.length===1){ mouseDown = true; lastMouse.x = e.touches[0].clientX; lastMouse.y = e.touches[0].clientY; } }
    function onTouchMove(e){ if (!fallbackMouseLook || !mouseDown) return; if (e.touches && e.touches.length===1){ const t = e.touches[0]; const movementX = t.clientX - lastMouse.x; const movementY = t.clientY - lastMouse.y; lastMouse.x = t.clientX; lastMouse.y = t.clientY; playerHolder.rotation.y -= movementX * (sensitivity*0.9); camera.rotation.x -= movementY * (sensitivity*0.9); camera.rotation.x = Math.max(-Math.PI/2 + 0.01, Math.min(Math.PI/2 - 0.01, camera.rotation.x)); e.preventDefault(); } }

    enableMouseLookBtn.addEventListener('click', ()=> enableMouseLook());
    openNewTabBtn.addEventListener('click', ()=>{ try{ window.open(location.href, '_blank'); }catch(e){ alert('새 탭 열기 실패: 페이지를 복사하여 새 탭에서 열어보세요.'); } });

    // --- 유틸: pointerlock 상태 체크 (iframe 권한 문제 진단 도움) ---
    // 만약 이 문서가 iframe 안에 있고 allow-pointer-lock가 없다면 포인터락이 차단됩니다.
    // 개발자가 iframe을 제어할 수 있으면 <iframe allow="...;allow-pointer-lock"> 를 설정하세요.

    // --- 시작 애니메이션 루프 ---
    animate();

    // --- 디버그: 콘솔 키 ---
    window.addEventListener('keydown',(e)=>{ if (e.key==='`') console.log('pos', controls.getObject().position); });

  </script>
</body>
</html>
